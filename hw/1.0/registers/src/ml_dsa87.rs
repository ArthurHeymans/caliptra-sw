// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at 7c953512251707d6f77d7d9a2f6be186ed013d50
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct MlDsa87Reg {
    _priv: (),
}
impl MlDsa87Reg {
    pub const PTR: *mut u32 = 0x10030000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Two 32-bit read-only registers representing of the name
    /// of ML_DSA87 component.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn name(&self) -> ureg::Array<2, ureg::RegRef<crate::ml_dsa87::meta::Name, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Two 32-bit read-only registers representing of the version
    /// of ML_DSA87 component.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn version(&self) -> ureg::Array<2, ureg::RegRef<crate::ml_dsa87::meta::Version, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// ML_DSA87 component control register type definition
    ///
    /// Read value: [`ml_dsa87::regs::CtrlReadVal`]; Write value: [`ml_dsa87::regs::CtrlWriteVal`]
    #[inline(always)]
    pub fn ctrl(&self) -> ureg::RegRef<crate::ml_dsa87::meta::Ctrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// ML_DSA87 component status register type definition
    ///
    /// Read value: [`ml_dsa87::regs::StatusReadVal`]; Write value: [`ml_dsa87::regs::StatusWriteVal`]
    #[inline(always)]
    pub fn status(&self) -> ureg::RegRef<crate::ml_dsa87::meta::Status, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// ML_DSA87 component IV register type definition
    /// 16 32-bit registers storing the 512-bit IV required
    /// for SCA countermeasures to randomize the inputs with no change
    /// on the ML_DSA87 outputs.
    /// The IV can be any 512-bit value in [0 : 2^512-1].
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn iv(&self) -> ureg::Array<16, ureg::RegRef<crate::ml_dsa87::meta::Iv, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x80 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// ML_DSA87 component seed register type definition
    /// 8 32-bit registers storing the 256-bit seed for keygen in big-endian representation.
    /// The seed can be any 256-bit value in [0 : 2^256-1].
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn seed(&self) -> ureg::Array<8, ureg::RegRef<crate::ml_dsa87::meta::Seed, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x100 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// ML_DSA87 SIGN RND register type definition
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn sign_rnd(&self) -> ureg::Array<8, ureg::RegRef<crate::ml_dsa87::meta::SignRnd, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x180 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// ML_DSA87 component hashed message register type definition
    /// 16 32-bit registers storing the hash of the message respect
    /// to SHA512 algorithm in big-endian representation.
    /// The hashed message can be any 512-bit value in [0 : 2^512-1].
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn msg(&self) -> ureg::Array<16, ureg::RegRef<crate::ml_dsa87::meta::Msg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x200 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// ML_DSA87 verification result.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn verification_result(
        &self,
    ) -> ureg::Array<16, ureg::RegRef<crate::ml_dsa87::meta::VerificationResult, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x280 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// ML_DSA87 SECRET KEY OUT. Used by keygen.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn secret_key_out(
        &self,
    ) -> ureg::Array<1224, ureg::RegRef<crate::ml_dsa87::meta::SecretKeyOut, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x300 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// ML_DSA87 SECRET KEY IN. Used by sign.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn secret_key_in(
        &self,
    ) -> ureg::Array<1224, ureg::RegRef<crate::ml_dsa87::meta::SecretKeyIn, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x1620 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// ML_DSA87 SECRET KEY OUT. Used by verify and keygen.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn public_key(
        &self,
    ) -> ureg::Array<648, ureg::RegRef<crate::ml_dsa87::meta::PublicKey, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x2940 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// ML_DSA87 Signature. Used by verify and sign.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn signature(
        &self,
    ) -> ureg::Array<1157, ureg::RegRef<crate::ml_dsa87::meta::Signature, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x3400 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    #[inline(always)]
    pub fn intr_block_rf(&self) -> IntrBlockRfBlock<&TMmio> {
        IntrBlockRfBlock {
            ptr: unsafe { self.ptr.add(0x800 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
}
#[derive(Clone, Copy)]
pub struct IntrBlockRfBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> IntrBlockRfBlock<TMmio> {
    /// Dedicated register with one bit for each event type that may produce an interrupt.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrEnTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrEnTWriteVal`]
    #[inline(always)]
    pub fn global_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfGlobalIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`ml_dsa87::regs::ErrorIntrEnTReadVal`]; Write value: [`ml_dsa87::regs::ErrorIntrEnTWriteVal`]
    #[inline(always)]
    pub fn error_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfErrorIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`ml_dsa87::regs::NotifIntrEnTReadVal`]; Write value: [`ml_dsa87::regs::NotifIntrEnTWriteVal`]
    #[inline(always)]
    pub fn notif_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfNotifIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of any interrupt event
    /// of a given type. E.g. Notifications and Errors may drive
    /// to two separate interrupt registers. There may be
    /// multiple sources of Notifications or Errors that are
    /// aggregated into a single interrupt pin for that
    /// respective type. That pin feeds through this register
    /// in order to apply a global enablement of that interrupt
    /// event type.
    /// Nonsticky assertion.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrTWriteVal`]
    #[inline(always)]
    pub fn error_global_intr_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfErrorGlobalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of any interrupt event
    /// of a given type. E.g. Notifications and Errors may drive
    /// to two separate interrupt registers. There may be
    /// multiple sources of Notifications or Errors that are
    /// aggregated into a single interrupt pin for that
    /// respective type. That pin feeds through this register
    /// in order to apply a global enablement of that interrupt
    /// event type.
    /// Nonsticky assertion.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrTWriteVal`]
    #[inline(always)]
    pub fn notif_global_intr_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfNotifGlobalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`ml_dsa87::regs::ErrorIntrTReadVal`]; Write value: [`ml_dsa87::regs::ErrorIntrTWriteVal`]
    #[inline(always)]
    pub fn error_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfErrorInternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`ml_dsa87::regs::NotifIntrTReadVal`]; Write value: [`ml_dsa87::regs::NotifIntrTWriteVal`]
    #[inline(always)]
    pub fn notif_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfNotifInternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`ml_dsa87::regs::ErrorIntrTrigTReadVal`]; Write value: [`ml_dsa87::regs::ErrorIntrTrigTWriteVal`]
    #[inline(always)]
    pub fn error_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfErrorIntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`ml_dsa87::regs::NotifIntrTrigTReadVal`]; Write value: [`ml_dsa87::regs::NotifIntrTrigTWriteVal`]
    #[inline(always)]
    pub fn notif_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfNotifIntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_internal_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfErrorInternalIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x100 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_cmd_done_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfNotifCmdDoneIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x180 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_internal_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfErrorInternalIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x200 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_cmd_done_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::ml_dsa87::meta::IntrBlockRfNotifCmdDoneIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x204 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct CtrlWriteVal(u32);
    impl CtrlWriteVal {
        /// Control command field: This can be:
        /// [br]             00 for NONE
        /// [br]             01 for KEYGEN
        /// [br]             10 for SIGNING
        /// [br]             11 for VERIFYING
        /// [br] After each software write, hardware will erase the register
        #[inline(always)]
        pub fn ctrl(
            self,
            f: impl FnOnce(super::enums::selector::CtrlSelector) -> super::enums::Ctrl,
        ) -> Self {
            Self((self.0 & !(3 << 0)) | (u32::from(f(super::enums::selector::CtrlSelector())) << 0))
        }
        /// Zeroize all internal registers: Zeroize all internal registers after ML_DSA87 process, to avoid SCA leakage.
        /// [br] Software write generates only a single-cycle pulse on the
        /// hardware interface and then will be erased
        #[inline(always)]
        pub fn zeroize(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for CtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusReadVal(u32);
    impl StatusReadVal {
        /// Status ready bit: ​Indicates if the core is ready to take
        /// a control command and process the block.
        #[inline(always)]
        pub fn ready(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Status valid bit: ​Indicates if the process is done and the
        /// hash value stored in DIGEST registers is valid.
        #[inline(always)]
        pub fn valid(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for StatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: StatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrEnTReadVal(u32);
    impl ErrorIntrEnTReadVal {
        /// Enable bit for Internal Errors
        #[inline(always)]
        pub fn error_internal_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrEnTWriteVal {
            ErrorIntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrEnTWriteVal(u32);
    impl ErrorIntrEnTWriteVal {
        /// Enable bit for Internal Errors
        #[inline(always)]
        pub fn error_internal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for ErrorIntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTReadVal(u32);
    impl ErrorIntrTReadVal {
        /// Internal Errors status bit
        #[inline(always)]
        pub fn error_internal_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrTWriteVal {
            ErrorIntrTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTWriteVal(u32);
    impl ErrorIntrTWriteVal {
        /// Internal Errors status bit
        #[inline(always)]
        pub fn error_internal_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for ErrorIntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTrigTReadVal(u32);
    impl ErrorIntrTrigTReadVal {
        /// Internal Errors trigger bit
        #[inline(always)]
        pub fn error_internal_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrTrigTWriteVal {
            ErrorIntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTrigTWriteVal(u32);
    impl ErrorIntrTrigTWriteVal {
        /// Internal Errors trigger bit
        #[inline(always)]
        pub fn error_internal_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for ErrorIntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrEnTReadVal(u32);
    impl NotifIntrEnTReadVal {
        /// Enable bit for Command Done
        #[inline(always)]
        pub fn notif_cmd_done_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrEnTWriteVal {
            NotifIntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrEnTWriteVal(u32);
    impl NotifIntrEnTWriteVal {
        /// Enable bit for Command Done
        #[inline(always)]
        pub fn notif_cmd_done_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for NotifIntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTReadVal(u32);
    impl NotifIntrTReadVal {
        /// Command Done status bit
        #[inline(always)]
        pub fn notif_cmd_done_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrTWriteVal {
            NotifIntrTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTWriteVal(u32);
    impl NotifIntrTWriteVal {
        /// Command Done status bit
        #[inline(always)]
        pub fn notif_cmd_done_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for NotifIntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTrigTReadVal(u32);
    impl NotifIntrTrigTReadVal {
        /// Command Done trigger bit
        #[inline(always)]
        pub fn notif_cmd_done_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrTrigTWriteVal {
            NotifIntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTrigTWriteVal(u32);
    impl NotifIntrTrigTWriteVal {
        /// Command Done trigger bit
        #[inline(always)]
        pub fn notif_cmd_done_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for NotifIntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    #[derive(Clone, Copy, Eq, PartialEq)]
    #[repr(u32)]
    pub enum Ctrl {
        None = 0,
        Keygen = 1,
        Signing = 2,
        Verifying = 3,
    }
    impl Ctrl {
        #[inline(always)]
        pub fn none(&self) -> bool {
            *self == Self::None
        }
        #[inline(always)]
        pub fn keygen(&self) -> bool {
            *self == Self::Keygen
        }
        #[inline(always)]
        pub fn signing(&self) -> bool {
            *self == Self::Signing
        }
        #[inline(always)]
        pub fn verifying(&self) -> bool {
            *self == Self::Verifying
        }
    }
    impl TryFrom<u32> for Ctrl {
        type Error = ();
        #[inline(always)]
        fn try_from(val: u32) -> Result<Ctrl, ()> {
            if val < 4 {
                Ok(unsafe { core::mem::transmute(val) })
            } else {
                Err(())
            }
        }
    }
    impl From<Ctrl> for u32 {
        fn from(val: Ctrl) -> Self {
            val as u32
        }
    }
    pub mod selector {
        pub struct CtrlSelector();
        impl CtrlSelector {
            #[inline(always)]
            pub fn none(&self) -> super::Ctrl {
                super::Ctrl::None
            }
            #[inline(always)]
            pub fn keygen(&self) -> super::Ctrl {
                super::Ctrl::Keygen
            }
            #[inline(always)]
            pub fn signing(&self) -> super::Ctrl {
                super::Ctrl::Signing
            }
            #[inline(always)]
            pub fn verifying(&self) -> super::Ctrl {
                super::Ctrl::Verifying
            }
        }
    }
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type Name = ureg::ReadOnlyReg32<u32>;
    pub type Version = ureg::ReadOnlyReg32<u32>;
    pub type Ctrl = ureg::WriteOnlyReg32<0, crate::ml_dsa87::regs::CtrlWriteVal>;
    pub type Status = ureg::ReadOnlyReg32<crate::ml_dsa87::regs::StatusReadVal>;
    pub type Iv = ureg::WriteOnlyReg32<0, u32>;
    pub type Seed = ureg::WriteOnlyReg32<0, u32>;
    pub type SignRnd = ureg::WriteOnlyReg32<0, u32>;
    pub type Msg = ureg::WriteOnlyReg32<0, u32>;
    pub type VerificationResult = ureg::ReadOnlyReg32<u32>;
    pub type SecretKeyOut = ureg::ReadOnlyReg32<u32>;
    pub type SecretKeyIn = ureg::WriteOnlyReg32<0, u32>;
    pub type PublicKey = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Signature = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfGlobalIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::sha512_acc::regs::GlobalIntrEnTReadVal,
        crate::sha512_acc::regs::GlobalIntrEnTWriteVal,
    >;
    pub type IntrBlockRfErrorIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::ml_dsa87::regs::ErrorIntrEnTReadVal,
        crate::ml_dsa87::regs::ErrorIntrEnTWriteVal,
    >;
    pub type IntrBlockRfNotifIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::ml_dsa87::regs::NotifIntrEnTReadVal,
        crate::ml_dsa87::regs::NotifIntrEnTWriteVal,
    >;
    pub type IntrBlockRfErrorGlobalIntrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::GlobalIntrTReadVal>;
    pub type IntrBlockRfNotifGlobalIntrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::GlobalIntrTReadVal>;
    pub type IntrBlockRfErrorInternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::ml_dsa87::regs::ErrorIntrTReadVal,
        crate::ml_dsa87::regs::ErrorIntrTWriteVal,
    >;
    pub type IntrBlockRfNotifInternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::ml_dsa87::regs::NotifIntrTReadVal,
        crate::ml_dsa87::regs::NotifIntrTWriteVal,
    >;
    pub type IntrBlockRfErrorIntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::ml_dsa87::regs::ErrorIntrTrigTReadVal,
        crate::ml_dsa87::regs::ErrorIntrTrigTWriteVal,
    >;
    pub type IntrBlockRfNotifIntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::ml_dsa87::regs::NotifIntrTrigTReadVal,
        crate::ml_dsa87::regs::NotifIntrTrigTWriteVal,
    >;
    pub type IntrBlockRfErrorInternalIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifCmdDoneIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorInternalIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifCmdDoneIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
}
