// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at 7c953512251707d6f77d7d9a2f6be186ed013d50
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct RecoveryReg {
    _priv: (),
}
impl RecoveryReg {
    pub const PTR: *mut u32 = 0x10038000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Two 32-bit read-only registers representing of the name
    /// of RECOVERY component.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn name(&self) -> ureg::Array<2, ureg::RegRef<crate::recovery::meta::Name, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 32-bit read-only registers representing of the version and capabilities
    /// of RECOVERY component.
    ///
    /// Read value: [`recovery::regs::VersionCapReadVal`]; Write value: [`recovery::regs::VersionCapWriteVal`]
    #[inline(always)]
    pub fn version_cap(&self) -> ureg::RegRef<crate::recovery::meta::VersionCap, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 32-bit read-only registers representing of the number of recovery memory spaces and timing information.
    ///
    /// Read value: [`recovery::regs::MemorySpaceTimingReadVal`]; Write value: [`recovery::regs::MemorySpaceTimingWriteVal`]
    #[inline(always)]
    pub fn memory_space_timing(
        &self,
    ) -> ureg::RegRef<crate::recovery::meta::MemorySpaceTiming, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 6 32-bit read-only registers respresenting the device id.
    /// Fist byte is type. Second bytes is string lenght. Last 22 bytes are ID.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id(
        &self,
    ) -> ureg::Array<6, ureg::RegRef<crate::recovery::meta::DeviceId, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 32-biut read-only register representing the device status.
    ///
    /// Read value: [`recovery::regs::DeviceInfoReadVal`]; Write value: [`recovery::regs::DeviceInfoWriteVal`]
    #[inline(always)]
    pub fn device_info(&self) -> ureg::RegRef<crate::recovery::meta::DeviceInfo, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// read-only register containing hearthbeat.
    ///
    /// Read value: [`recovery::regs::HeartbeatReadVal`]; Write value: [`recovery::regs::HeartbeatWriteVal`]
    #[inline(always)]
    pub fn heartbeat(&self) -> ureg::RegRef<crate::recovery::meta::Heartbeat, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RW reset control register.
    ///
    /// Read value: [`recovery::regs::ResetControlReadVal`]; Write value: [`recovery::regs::ResetControlWriteVal`]
    #[inline(always)]
    pub fn reset_control(&self) -> ureg::RegRef<crate::recovery::meta::ResetControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RW recovery register interface control
    ///
    /// Read value: [`recovery::regs::ControlReadVal`]; Write value: [`recovery::regs::ControlWriteVal`]
    #[inline(always)]
    pub fn control(&self) -> ureg::RegRef<crate::recovery::meta::Control, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read-only recovery status register
    ///
    /// Read value: [`recovery::regs::StatusReadVal`]; Write value: [`recovery::regs::StatusWriteVal`]
    #[inline(always)]
    pub fn status(&self) -> ureg::RegRef<crate::recovery::meta::Status, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read-only hardware status register
    ///
    /// Read value: [`recovery::regs::HwStatusReadVal`]; Write value: [`recovery::regs::HwStatusWriteVal`]
    #[inline(always)]
    pub fn hw_status(&self) -> ureg::RegRef<crate::recovery::meta::HwStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read Write register for controller the indirect FIFO.
    ///
    /// Read value: [`recovery::regs::IndirectFifoControlReadVal`]; Write value: [`recovery::regs::IndirectFifoControlWriteVal`]
    #[inline(always)]
    pub fn indirect_fifo_control(
        &self,
    ) -> ureg::RegRef<crate::recovery::meta::IndirectFifoControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read Write register for the indirect FIFO image size
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_image_size(
        &self,
    ) -> ureg::RegRef<crate::recovery::meta::IndirectFifoImageSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read-Only register indicating indirect FIFO status
    ///
    /// Read value: [`recovery::regs::IndirectFifoStatusReadVal`]; Write value: [`recovery::regs::IndirectFifoStatusWriteVal`]
    #[inline(always)]
    pub fn indirect_fifo_status(
        &self,
    ) -> ureg::RegRef<crate::recovery::meta::IndirectFifoStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read-only register indicating write address in units of 4 bytes
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn write_index(&self) -> ureg::RegRef<crate::recovery::meta::WriteIndex, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read-only register indicating read address in units of 4 bytes
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn read_index(&self) -> ureg::RegRef<crate::recovery::meta::ReadIndex, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x50 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read-only register indicating the size of the indirect FIFO in units of 4 bytes
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_size(&self) -> ureg::RegRef<crate::recovery::meta::IndirectSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x54 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read-only register indicating the max size of a transfer to/from the FIFO in units of 4 bytes
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn max_transfer_size(
        &self,
    ) -> ureg::RegRef<crate::recovery::meta::MaxTransferSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read-only register holding the FIFO data
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fifo_data(&self) -> ureg::RegRef<crate::recovery::meta::FifoData, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x6c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct ControlReadVal(u32);
    impl ControlReadVal {
        /// Content memory space
        #[inline(always)]
        pub fn cms(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Image selection
        /// No operation - 0
        /// Recovery from CMS - 1
        /// Recovery stored on device - 2
        #[inline(always)]
        pub fn image_selection(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Activate recovery image
        /// Do not activate - 0
        /// Activate - 0xf
        #[inline(always)]
        pub fn activate_recovery_image(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ControlWriteVal {
            ControlWriteVal(self.0)
        }
    }
    impl From<u32> for ControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: ControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControlWriteVal(u32);
    impl ControlWriteVal {
        /// Content memory space
        #[inline(always)]
        pub fn cms(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
        /// Image selection
        /// No operation - 0
        /// Recovery from CMS - 1
        /// Recovery stored on device - 2
        #[inline(always)]
        pub fn image_selection(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// Activate recovery image
        /// Do not activate - 0
        /// Activate - 0xf
        #[inline(always)]
        pub fn activate_recovery_image(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
    }
    impl From<u32> for ControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DeviceInfoReadVal(u32);
    impl DeviceInfoReadVal {
        /// Device Status
        #[inline(always)]
        pub fn status(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Protocol Error
        #[inline(always)]
        pub fn error(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Recovery Reason
        #[inline(always)]
        pub fn recovery_reason(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
    }
    impl From<u32> for DeviceInfoReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DeviceInfoReadVal> for u32 {
        #[inline(always)]
        fn from(val: DeviceInfoReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HeartbeatReadVal(u32);
    impl HeartbeatReadVal {
        /// Heartbeat
        #[inline(always)]
        pub fn heartbeat(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
    }
    impl From<u32> for HeartbeatReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HeartbeatReadVal> for u32 {
        #[inline(always)]
        fn from(val: HeartbeatReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwStatusReadVal(u32);
    impl HwStatusReadVal {
        /// Hardware status
        /// Temperature critical - 0
        /// Hardware soft error - 1
        /// Hardware fatal error - 2
        #[inline(always)]
        pub fn hw_status(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Vendor hardware status
        #[inline(always)]
        pub fn vendor_hw_status(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Composite temperature
        /// 0x00-0x7e: 0 to 126 C
        /// 0x7f: 127 C or higher
        /// 0x80: no temperature data, or data is older than 5 seconds
        /// 0x81: temperature sensor failure
        /// 0x82-0x83: reserved
        /// 0xc4: -60 C or lower
        /// 0xc5-0xff: -1 to -59 C (in twoʼs complement)
        #[inline(always)]
        pub fn composite_temp(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for HwStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IndirectFifoControlReadVal(u32);
    impl IndirectFifoControlReadVal {
        /// Component memory space
        #[inline(always)]
        pub fn cms(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Reset
        #[inline(always)]
        pub fn reset(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IndirectFifoControlWriteVal {
            IndirectFifoControlWriteVal(self.0)
        }
    }
    impl From<u32> for IndirectFifoControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IndirectFifoControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: IndirectFifoControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IndirectFifoControlWriteVal(u32);
    impl IndirectFifoControlWriteVal {
        /// Component memory space
        #[inline(always)]
        pub fn cms(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
        /// Reset
        #[inline(always)]
        pub fn reset(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
    }
    impl From<u32> for IndirectFifoControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IndirectFifoControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IndirectFifoControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IndirectFifoStatusReadVal(u32);
    impl IndirectFifoStatusReadVal {
        /// FIFO empty
        #[inline(always)]
        pub fn empty(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// FIFO full
        #[inline(always)]
        pub fn full(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Region Type
        /// Code space recovery - 0
        /// Log with debug format - 1
        /// Vendor defined write only region - 4
        /// Vendor defined read only region - 5
        /// Unsupported region - 7
        #[inline(always)]
        pub fn region_type(&self) -> u32 {
            (self.0 >> 8) & 7
        }
    }
    impl From<u32> for IndirectFifoStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IndirectFifoStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: IndirectFifoStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MemorySpaceTimingReadVal(u32);
    impl MemorySpaceTimingReadVal {
        /// Number of component memory spaces
        #[inline(always)]
        pub fn component_memory_spaces(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Maximum response time in ln(x) us
        #[inline(always)]
        pub fn max_response_time(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Heartbeat period in ln(x) us
        #[inline(always)]
        pub fn hearthbeat_period(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
    }
    impl From<u32> for MemorySpaceTimingReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MemorySpaceTimingReadVal> for u32 {
        #[inline(always)]
        fn from(val: MemorySpaceTimingReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetControlReadVal(u32);
    impl ResetControlReadVal {
        /// Reset control
        /// No reset - 0x0
        /// Reset Device - 0x1
        /// Reset Management - 0x2
        #[inline(always)]
        pub fn device_reset(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Forced reset
        /// No Forced reset mode - 0x0
        /// Recovery Mode - 0xf
        #[inline(always)]
        pub fn forced_reset(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Activate recovery image
        /// Do not activate - 0x0
        /// Activate - 0xf
        #[inline(always)]
        pub fn activate_recovery_image(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ResetControlWriteVal {
            ResetControlWriteVal(self.0)
        }
    }
    impl From<u32> for ResetControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: ResetControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetControlWriteVal(u32);
    impl ResetControlWriteVal {
        /// Reset control
        /// No reset - 0x0
        /// Reset Device - 0x1
        /// Reset Management - 0x2
        #[inline(always)]
        pub fn device_reset(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
        /// Forced reset
        /// No Forced reset mode - 0x0
        /// Recovery Mode - 0xf
        #[inline(always)]
        pub fn forced_reset(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// Activate recovery image
        /// Do not activate - 0x0
        /// Activate - 0xf
        #[inline(always)]
        pub fn activate_recovery_image(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
    }
    impl From<u32> for ResetControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ResetControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusReadVal(u32);
    impl StatusReadVal {
        /// Recovery status:
        /// Not in recovery - 0
        /// Awaiting recovery image - 1
        /// Booting recovery image - 2
        /// Recovery succesfull - 3
        /// Recovery failed - 12
        /// Authenmtocation failed - 13
        /// Error entering recovery mode - 14
        /// Invalid component address space - 15
        #[inline(always)]
        pub fn device_recovery(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for StatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: StatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct VersionCapReadVal(u32);
    impl VersionCapReadVal {
        /// Major Version field
        #[inline(always)]
        pub fn major_version(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Minor Version field
        #[inline(always)]
        pub fn minor_version(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Identification field
        #[inline(always)]
        pub fn identification(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        /// Forced Recovery field
        #[inline(always)]
        pub fn forced_recovery(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        /// Management reset field
        #[inline(always)]
        pub fn mgmt_reset(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        /// Device Status field
        #[inline(always)]
        pub fn device_status(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        /// Local C image field
        #[inline(always)]
        pub fn local_c_image(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// Push C image field
        #[inline(always)]
        pub fn push_c_image(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        /// Interface Isolation field
        #[inline(always)]
        pub fn interface_isolation(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// Hardware Status field
        #[inline(always)]
        pub fn hardware_status(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        /// Vendors Command field
        #[inline(always)]
        pub fn vendors_command(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
    }
    impl From<u32> for VersionCapReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<VersionCapReadVal> for u32 {
        #[inline(always)]
        fn from(val: VersionCapReadVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type Name = ureg::ReadOnlyReg32<u32>;
    pub type VersionCap = ureg::ReadOnlyReg32<crate::recovery::regs::VersionCapReadVal>;
    pub type MemorySpaceTiming =
        ureg::ReadOnlyReg32<crate::recovery::regs::MemorySpaceTimingReadVal>;
    pub type DeviceId = ureg::ReadOnlyReg32<u32>;
    pub type DeviceInfo = ureg::ReadOnlyReg32<crate::recovery::regs::DeviceInfoReadVal>;
    pub type Heartbeat = ureg::ReadOnlyReg32<crate::recovery::regs::HeartbeatReadVal>;
    pub type ResetControl = ureg::ReadWriteReg32<
        0,
        crate::recovery::regs::ResetControlReadVal,
        crate::recovery::regs::ResetControlWriteVal,
    >;
    pub type Control = ureg::ReadWriteReg32<
        0,
        crate::recovery::regs::ControlReadVal,
        crate::recovery::regs::ControlWriteVal,
    >;
    pub type Status = ureg::ReadOnlyReg32<crate::recovery::regs::StatusReadVal>;
    pub type HwStatus = ureg::ReadOnlyReg32<crate::recovery::regs::HwStatusReadVal>;
    pub type IndirectFifoControl = ureg::ReadWriteReg32<
        0,
        crate::recovery::regs::IndirectFifoControlReadVal,
        crate::recovery::regs::IndirectFifoControlWriteVal,
    >;
    pub type IndirectFifoImageSize = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IndirectFifoStatus =
        ureg::ReadOnlyReg32<crate::recovery::regs::IndirectFifoStatusReadVal>;
    pub type WriteIndex = ureg::ReadOnlyReg32<u32>;
    pub type ReadIndex = ureg::ReadOnlyReg32<u32>;
    pub type IndirectSize = ureg::ReadOnlyReg32<u32>;
    pub type MaxTransferSize = ureg::ReadOnlyReg32<u32>;
    pub type FifoData = ureg::ReadOnlyReg32<u32>;
}
